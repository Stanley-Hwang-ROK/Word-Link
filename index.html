<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Word-Link Puzzle — Click-to-Swap</title>
  <meta name="theme-color" content="#0f172a">

  <style>
    :root { --bg:#0f172a; --panel:#111827; --tile:#1f2937; --tileSel:#2563eb; --text:#e5e7eb; }
    body { margin:0; font-family: system-ui; background:var(--bg); color:var(--text); display:flex; min-height:100vh; }
    .wrap { margin:auto; width:min(95vw, 900px); }
    header { display:flex; align-items:center; justify-content:space-between; padding:12px 0; }

    .board {
      display:grid;
      gap:6px;
      padding:10px;
      grid-template-columns:repeat(8,48px);
      justify-content:center;
    }

    .tile {
      width:48px; height:48px;
      display:grid; place-items:center;
      border-radius:8px;
      background:var(--tile);
      color:#fff; font-weight:800; font-size:20px;
      user-select:none;
      border:1px solid #374151;
      transition:transform .08s ease;
    }
    .tile.sel { background:var(--tileSel); transform:scale(1.05); }
    .tile.match {
      background:#f59e0b;
      transform:scale(1.2);
      transition:all .3s ease;
    }

    .hud { display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 12px; }
    .badge { background:var(--panel); padding:6px 10px; border-radius:999px; font-weight:700; }
    .msg { min-height:20px; opacity:.9; }

    .category-btn {
      padding:10px 16px;
      font-size:16px;
      margin:6px;
      border-radius:6px;
      background:#2563eb;
      color:white;
      border:none;
      cursor:pointer;
    }

    /* Moves 표시 강조 */
    #moves {
      font-weight:900;
      color:#facc15;
      transition:transform .15s ease;
    }
    #moves.bump { transform:scale(1.25); }
    /* Game Over Overlay */
#gameover-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0,0,0,0.7);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  animation: fadeIn 0.8s ease forwards;
}

#gameover-text {
  font-size: 60px;
  font-weight: 900;
  color: #facc15;
  text-shadow: 0 0 20px #000;
  animation: pulse 1s infinite alternate;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}
@keyframes pulse {
  from { transform: scale(0.9); opacity: 0.7; }
  to   { transform: scale(1.1); opacity: 1; }
}

  </style>
</head>

<body>
  <div class="wrap">

    <header>
      <h1 style="margin:0;font-size:20px">Word-Link (Click-to-Swap)</h1>
      <div>
        <!-- Hint 제거됨 -->
        <button id="btnShuffle">Shuffle</button>
        <button id="btnNew">New Game</button>
      </div>
    </header>

    <!-- 카테고리 선택 메뉴 -->
    <div id="category-menu" style="text-align:center; margin:20px 0;">
      <h2>Select a Category</h2>
      <button class="category-btn" data-cat="animal">Animals</button>
      <button class="category-btn" data-cat="plant">Plants</button>
      <button class="category-btn" data-cat="jobs">Jobs & Places</button>
    </div>

    <div class="hud">
      <div class="badge">Score: <span id="score">0</span></div>
      <!-- Selected 제거됨 -->
      <div class="badge">Moves: <span id="moves">10</span></div>
      <div class="badge">Dict: <span id="dictCount">0</span></div>
    </div>

    <div id="board" class="board"></div>
    <div id="msg" class="msg">카테고리를 먼저 선택하세요.</div>

  </div>

<script>
/* ===============================
   Word-Link Puzzle (Category + Moves)
   =============================== */

const ROWS = 10, COLS = 8, MIN_WORD = 3, MAX_WORD = 6;
const COLORS = ["#f87171","#fbbf24","#34d399","#60a5fa","#a78bfa","#f472b6","#facc15","#38bdf8"];

// 카테고리 단어
const CATEGORY_WORDS = {
  animal: ["CAT","DOG","LION","TIGER","BEAR","FROG","BIRD","FISH","COW","PIG","FOX","DEER","BEE","DUCK"],
  plant:  ["TREE","LEAF","ROSE","GRASS","SEED","FLOWER","ROOT","MOSS","BAMBOO","OAK","PINE","LILY"],
  jobs:   ["DOCTOR","NURSE","TEACHER","PILOT","CHEF","FARMER","POLICE","DRIVER","ARTIST","BAKER","CLERK","GUIDE"]
};

let LETTER_BAG = "";
function buildLetterBag(list){ return list.join(""); }

let DICTIONARY = new Set();
let grid = Array.from({length:ROWS},()=>Array(COLS).fill(""));
let colorGrid = Array.from({length:ROWS},()=>Array(COLS).fill(null));

let score = 0;
let moves = 10;
let firstSel = null;

// DOM
const elBoard = document.getElementById("board");
const elMsg   = document.getElementById("msg");
const elScore = document.getElementById("score");
const elMoves = document.getElementById("moves");
const elDict  = document.getElementById("dictCount");

// UI 업데이트
function setMsg(t){ elMsg.textContent = t; }
function updateScore(){ elScore.textContent = score; }
function updateMoves(){
  elMoves.textContent = moves;
  elMoves.classList.add("bump");
  setTimeout(()=> elMoves.classList.remove("bump"),150);
}

// 보드 관련
function randLetter(){
  if (LETTER_BAG.length){
    return LETTER_BAG[Math.floor(Math.random()*LETTER_BAG.length)];
  }
  const bag = "EEEEEEAAA AAI IIOOOUU"
             + "NNNRRRTTTLLSS"
             + "DGG" + "BCMP" + "FHVWY" + "K" + "JX" + "QZ";
  return bag.replace(/\s/g,"")[Math.floor(Math.random()*bag.length)];
}

function setupBoard(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      grid[r][c]=randLetter();
      colorGrid[r][c]=COLORS[Math.floor(Math.random()*COLORS.length)];
    }
  }
}

function renderAll(){
  elBoard.innerHTML="";
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const d=document.createElement("div");
      d.className="tile";
      d.dataset.r=r;
      d.dataset.c=c;
      d.textContent=grid[r][c];
      d.style.background=colorGrid[r][c];
      elBoard.appendChild(d);
    }
  }
}

// 이벤트 바인딩
bindUI();

function bindUI(){

  elBoard.addEventListener("click", onClickTile);

  // New Game → 카테고리 선택창 복귀
  document.getElementById("btnNew").onclick = () => {
    score = 0; updateScore();
    moves = 10; updateMoves();
    firstSel = null;

    // 보드 비우기
    grid = Array.from({length:ROWS},()=>Array(COLS).fill(""));
    colorGrid = Array.from({length:ROWS},()=>Array(COLS).fill(null));
    renderAll();

    // 카테고리 화면으로
    document.getElementById("category-menu").style.display = "block";
    setMsg("카테고리를 먼저 선택하세요.");
  };

  document.getElementById("btnShuffle").onclick = () => shuffleBoard();

  // 카테고리 선택
  document.querySelectorAll(".category-btn").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const cat=btn.dataset.cat;
      const words=CATEGORY_WORDS[cat];

      DICTIONARY=new Set(words);
      LETTER_BAG = buildLetterBag(words);
      elDict.textContent = DICTIONARY.size;

      // 보드 생성
      document.getElementById("category-menu").style.display="none";

      score=0; updateScore();
      moves=10; updateMoves();

      setupBoard();
      renderAll();

      setMsg(`${cat} category loaded (${DICTIONARY.size} words).`);
    });
  });
}

// 클릭 스왑
async function onClickTile(e){
  if (moves<=0){
    setMsg("Game Over — No moves left!");
document.getElementById("gameover-overlay").style.display = "flex";
return;

  }

  const t=e.target.closest(".tile");
  if(!t) return;

  const r=+t.dataset.r, c=+t.dataset.c;

  if(!firstSel){
    firstSel={r,c};
    highlight(r,c,true);
    return;
  }

  if(firstSel.r===r && firstSel.c===c){
    highlight(r,c,false);
    firstSel=null;
    return;
  }

  if(!isNeighbor(firstSel.r,firstSel.c,r,c)){
    highlight(firstSel.r,firstSel.c,false);
    firstSel={r,c};
    highlight(r,c,true);
    return;
  }

  // swap
  swap([firstSel.r,firstSel.c],[r,c]);
  highlight(firstSel.r,firstSel.c,false);
  highlight(r,c,false);
  firstSel=null;

  moves -= 1;
  updateMoves();

  if(moves<=0){
    renderAll();
   setMsg("Game Over — No moves left!");
document.getElementById("gameover-overlay").style.display = "flex";
return;

  }

  renderAll();
  await resolveMatchesCascade();
}

function highlight(r,c,on){
  const el=document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
  if(el) el.classList.toggle("sel",on);
}
function isNeighbor(r1,c1,r2,c2){
  return Math.abs(r1-r2)+Math.abs(c1-c2)===1;
}
function swap([r1,c1],[r2,c2]){
  [grid[r1][c1],grid[r2][c2]]=[grid[r2][c2],grid[r1][c1]];
  [colorGrid[r1][c1],colorGrid[r2][c2]]=[colorGrid[r2][c2],colorGrid[r1][c1]];
}

// 매치 처리
async function resolveMatchesCascade(){
  let total=0;
  let lastWord="";

  while(true){
    const marks=findMatches();
    if(marks.size===0) break;

    const res=await clearMarked(marks);
    total+=res.count;
    if(res.exampleWord) lastWord=res.exampleWord;

    applyGravity();
    refill();
    renderAll();
  }

  if(total>0){
    score+=total*5;
    updateScore();

    moves+=10;
    updateMoves();

    setMsg(
      lastWord ? `Cleared (${total}). ex: ${lastWord} — +10 moves`
               : `Cleared ${total} — +10 moves`
    );
  } else {
    setMsg("No match");
  }
}

function findMatches(){
  const marks=new Set();
  let example="";

  // 가로
  for(let r=0;r<ROWS;r++){
    let c=0;
    while(c<COLS){
      let c2=c;
      while(c2+1<COLS && grid[r][c2+1]) c2++;
      if(c2-c+1>=MIN_WORD){
        const letters=grid[r].slice(c,c2+1).join("");
        markSub(r,c,0,1,letters,marks,w=>example||=w);
      }
      c=c2+1;
    }
  }

  // 세로
  for(let c=0;c<COLS;c++){
    let r=0;
    while(r<ROWS){
      let r2=r;
      while(r2+1<ROWS && grid[r2+1][c]) r2++;
      if(r2-r+1>=MIN_WORD){
        let letters="";
        for(let i=r;i<=r2;i++) letters+=grid[i][c];
        markSub(r,c,1,0,letters,marks,w=>example||=w);
      }
      r=r2+1;
    }
  }

  marks.exampleWord=example;
  return marks;
}

function markSub(r0,c0,dr,dc,letters,marks,onExample){
  const n=letters.length;
  for(let len=MIN_WORD; len<=Math.min(n,MAX_WORD); len++){
    for(let s=0; s+len<=n; s++){
      const word=letters.slice(s,s+len).toUpperCase();
      if(DICTIONARY.has(word)){
        for(let k=0;k<len;k++){
          const rr=r0+(s+k)*dr;
          const cc=c0+(s+k)*dc;
          marks.add(`${rr},${cc}`);
        }
        if(onExample) onExample(word);
      }
    }
  }
}

async function clearMarked(marks){
  const exampleWord=marks.exampleWord||"";

  for(const pos of marks){
    const[r,c]=pos.split(",").map(Number);
    const el=document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
    if(el) el.classList.add("match");
  }
  await new Promise(res=>setTimeout(res,500));

  let count=0;
  for(const pos of marks){
    const[r,c]=pos.split(",").map(Number);
    if(grid[r][c]){
      grid[r][c]="";
      count++;
    }
  }

  renderAll();
  return {count,exampleWord};
}

function applyGravity(){
  for(let c=0;c<COLS;c++){
    let w=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(grid[r][c]){
        grid[w][c]=grid[r][c];
        if(w!==r) grid[r][c]="";
        w--;
      }
    }
  }
}

function refill(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(!grid[r][c]){
        grid[r][c]=randLetter();
        colorGrid[r][c]=COLORS[Math.floor(Math.random()*COLORS.length)];
      }
    }
  }
}

function shuffleBoard(){
  const arr=[];
  for(let r=0;r<ROWS;r++)
    for(let c=0;c<COLS;c++)
      arr.push(grid[r][c]);

  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }

  let k=0;
  for(let r=0;r<ROWS;r++)
    for(let c=0;c<COLS;c++)
      grid[r][c]=arr[k++];

  renderAll();
  setMsg("Shuffled");
}
</script>
<div id="gameover-overlay">
  <div id="gameover-text">GAME OVER</div>
</div>

</body>
</html>
