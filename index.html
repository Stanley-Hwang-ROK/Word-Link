<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Word-Link Puzzle â€” Click-to-Swap</title>
  <link rel="manifest" href="manifest.json?v=6">
  <meta name="theme-color" content="#0f172a">

  <style>
    :root { --bg:#0f172a; --panel:#111827; --tile:#1f2937; --tileSel:#2563eb; --text:#e5e7eb; }
    body { margin:0; font-family: system-ui; background:var(--bg); color:var(--text); display:flex; min-height:100vh; }
    .wrap { margin:auto; width:min(95vw, 900px); }
    header { display:flex; align-items:center; justify-content:space-between; padding:12px 0; }

    .board {
      display: grid;
      gap: 6px;
      padding: 10px;
      grid-template-columns: repeat(8, 48px);
      justify-content: center;
    }

    .tile {
      width:48px; height:48px;
      display:grid; place-items:center;
      border-radius:8px;
      background:var(--tile);
      color:#fff; font-weight:800; font-size:20px;
      user-select:none;
      border:1px solid #374151;
      transition:transform .08s ease;
    }

    .tile.sel { background:var(--tileSel); transform:scale(1.05); }

    .tile.match {
      background:#f59e0b;
      transform:scale(1.2);
      transition:all .3s ease;
    }

    .hud { display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 12px; }
    .badge { background:var(--panel); padding:6px 10px; border-radius:999px; font-weight:700; }
    .msg { min-height:20px; opacity:.9; }

    .category-btn {
      padding:10px 16px;
      font-size:16px;
      margin:6px;
      border-radius:6px;
      background:#2563eb;
      color:white;
      border:none;
      cursor:pointer;
    }
  </style>
</head>

<body>
<div class="wrap">

  <header>
    <h1 style="margin:0;font-size:20px">Word-Link (Click-to-Swap)</h1>
    <div>
      <button id="btnHint">Hint</button>
      <button id="btnShuffle">Shuffle</button>
      <button id="btnNew">New Game</button>
    </div>
  </header>

  <!-- â–¼ ì¹´í…Œê³ ë¦¬ ì„ íƒ ì˜ì—­ -->
  <div id="category-menu" style="text-align:center; margin:20px 0;">
    <h2>Select a Category</h2>
    <button class="category-btn" data-cat="animal">Animals</button>
    <button class="category-btn" data-cat="plant">Plants</button>
    <button class="category-btn" data-cat="jobs">Jobs & Places</button>
  </div>
  <!-- â–² ì¹´í…Œê³ ë¦¬ ì„ íƒ ì˜ì—­ ë -->

  <div class="hud">
    <div class="badge">Score: <span id="score">0</span></div>
    <div class="badge">Selected: <span id="currentWord"></span></div>
    <div class="badge">Moves: <span id="moves">10</span></div> <!-- ğŸ“Œ moves ì¶”ê°€ -->
  </div>

  <div id="board" class="board"></div>
  <div id="msg" class="msg">ì¹´í…Œê³ ë¦¬ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.</div>

</div> <!-- wrap ë -->

<script>
/* =========================
   Word-Link Puzzle (with Category + Move Limit)
   ========================= */

// ê¸°ë³¸ ì„¤ì •
const ROWS = 10, COLS = 8, MIN_WORD = 3, MAX_WORD = 6;
const COLORS = ["#f87171","#fbbf24","#34d399","#60a5fa","#a78bfa","#f472b6","#facc15","#38bdf8"];

// ğŸ”¹ ì¹´í…Œê³ ë¦¬ë³„ ë‹¨ì–´
const CATEGORY_WORDS = {
  animal: ["CAT","DOG","LION","TIGER","BEAR","FROG","BIRD","FISH","COW","PIG","FOX","DEER","BEE","DUCK"],
  plant: ["TREE","LEAF","ROSE","GRASS","SEED","FLOWER","ROOT","MOSS","BAMBOO","OAK","PINE","LILY"],
  jobs: ["DOCTOR","NURSE","TEACHER","PILOT","CHEF","FARMER","POLICE","DRIVER","ARTIST","BAKER","CLERK","GUIDE"]
};

// ğŸ”¹ ì¹´í…Œê³ ë¦¬ ê¸€ì ê°€ë°©
let LETTER_BAG = "";
function buildLetterBag(list) {
  return list.join("");  // ë‹¨ì–´ ëª¨ë‘ í•©ì¹œ ë¬¸ìì—´
}

// ìƒíƒœ ë³€ìˆ˜ë“¤
let DICTIONARY = new Set();
let grid = Array.from({length: ROWS}, () => Array(COLS).fill(""));
let colorGrid = Array.from({length: ROWS}, () => Array(COLS).fill(null));

let score = 0;
let moves = 10;           // ğŸ“Œ ìŠ¤ì™‘ ì œí•œ ê¸°ë³¸ 10
let firstSel = null;

// DOM
const elBoard = document.getElementById("board");
const elMsg   = document.getElementById("msg");
const elScore = document.getElementById("score");
const elMoves = document.getElementById("moves");
const elWord  = document.getElementById("currentWord");

// ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateScore(){ elScore.textContent = score; }
function updateMoves(){ elMoves.textContent = moves; }
function setMsg(t){ elMsg.textContent = t; }

// =====================================
// â–¼â–¼â–¼ PART 1 ë â€” PART 2ì—ì„œ ì´ì–´ì§ â–¼â–¼â–¼
// =====================================
<!-- â–¼â–¼â–¼ PART 2 ì‹œì‘ â–¼â–¼â–¼ -->

<script>

// =====================================
// â— ë³´ë“œ ìƒì„±
// =====================================
function randLetter() {
  if (LETTER_BAG.length > 0) {
    const i = Math.floor(Math.random() * LETTER_BAG.length);
    return LETTER_BAG[i];
  }

  // fallback
  const bag = "EEEEEEAAA AAI IIOOOUU"
             + "NNNRRRTTTLLSS"
             + "DGG" + "BCMP" + "FHVWY" + "K" + "JX" + "QZ";
  const letters = bag.replace(/\s/g, "");
  return letters[Math.floor(Math.random() * letters.length)];
}

function setupBoard() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      grid[r][c] = randLetter();
      colorGrid[r][c] = COLORS[Math.floor(Math.random() * COLORS.length)];
    }
  }
}

function renderAll() {
  elBoard.innerHTML = "";
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const d = document.createElement("div");
      d.className = "tile";
      d.dataset.r = r;
      d.dataset.c = c;
      d.textContent = grid[r][c];
      d.style.background = colorGrid[r][c];
      elBoard.appendChild(d);
    }
  }
}

// =====================================
// â— ì¹´í…Œê³ ë¦¬ ë²„íŠ¼, UI ë“± ì´ë²¤íŠ¸ ë°”ì¸ë”©
// =====================================
bindUI();
setMsg("ì¹´í…Œê³ ë¦¬ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.");

function bindUI() {

  // íƒ€ì¼ í´ë¦­ ìŠ¤ì™‘
  elBoard.addEventListener("click", onClickTile);

  // New Game
  document.getElementById("btnNew").onclick = () => {
    score = 0;
    moves = 10;
    updateScore();
    updateMoves();

    setupBoard();
    renderAll();
    setMsg("New board.");
  };

  // Shuffle
  document.getElementById("btnShuffle").onclick = () => shuffleBoard();

  // Hint
  document.getElementById("btnHint").onclick = () => {
    const h = findAnyMatch();
    setMsg(h ? `ì˜ˆ: ${h.word}` : "ê°€ëŠ¥í•œ ë‹¨ì–´ë¥¼ ëª» ì°¾ì•˜ì–´ìš”");
  };

  // =========================================
  // ğŸ“Œ ì¹´í…Œê³ ë¦¬ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
  // =========================================
  document.querySelectorAll(".category-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const cat = btn.dataset.cat;

      const words = CATEGORY_WORDS[cat];
      DICTIONARY = new Set(words);           // ì‚¬ì „ êµì²´
      LETTER_BAG = buildLetterBag(words);    // Letter bag ìƒì„±

      // HUD ì—…ë°ì´íŠ¸
      updateScore();
      updateMoves();
      if (document.getElementById("dictCount"))
        document.getElementById("dictCount").textContent = DICTIONARY.size;

      // ì¹´í…Œê³ ë¦¬ ë©”ë‰´ ìˆ¨ê¹€
      document.getElementById("category-menu").style.display = "none";

      // ë³´ë“œ ìƒì„±
      score = 0;
      moves = 10;
      updateScore();
      updateMoves();

      setupBoard();
      renderAll();

      setMsg(`${cat} category loaded (${DICTIONARY.size} words).`);
    });
  });
}

// =====================================
// â— ìŠ¤ì™‘ ë¡œì§ (moves ì ìš©)
// =====================================
async function onClickTile(e) {
  const t = e.target.closest(".tile");
  if (!t) return;

  const r = +t.dataset.r, c = +t.dataset.c;

  // ì²« ì„ íƒ
  if (!firstSel) {
    firstSel = { r, c };
    highlight(r, c, true);
    return;
  }

  // ê°™ì€ ì¹¸ ë‹¤ì‹œ í´ë¦­ â†’ ì„ íƒ í•´ì œ
  if (firstSel.r === r && firstSel.c === c) {
    highlight(r, c, false);
    firstSel = null;
    return;
  }

  // ì´ì›ƒì¹¸ ì•„ë‹ˆë©´ â†’ ì„ íƒ ë³€ê²½
  if (!isNeighbor(firstSel.r, firstSel.c, r, c)) {
    highlight(firstSel.r, firstSel.c, false);
    firstSel = { r, c };
    highlight(r, c, true);
    return;
  }

  // ===============================
  // â— ì‹¤ì œ ìŠ¤ì™‘
  // ===============================
  swap([firstSel.r, firstSel.c], [r, c]);
  highlight(firstSel.r, firstSel.c, false);
  highlight(r, c, false);
  firstSel = null;

  // ğŸ“Œ ìŠ¤ì™‘ ì‹œ moves -1
  moves -= 1;
  updateMoves();

  // movesê°€ 0 ì´í•˜ â†’ ê²Œì„ì˜¤ë²„
  if (moves <= 0) {
    renderAll();
    setMsg("Game Over â€” No moves left!");
    return;
  }

  renderAll();
  await resolveMatchesCascade();
}

function highlight(r, c, on) {
  const el = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
  if (el) el.classList.toggle("sel", on);
}
function isNeighbor(r1, c1, r2, c2) {
  return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
}

function swap([r1, c1], [r2, c2]) {
  let t = grid[r1][c1];
  grid[r1][c1] = grid[r2][c2];
  grid[r2][c2] = t;

  let tc = colorGrid[r1][c1];
  colorGrid[r1][c1] = colorGrid[r2][c2];
  colorGrid[r2][c2] = tc;
}

// =====================================
// â— ë§¤ì¹˜ íƒìƒ‰ ë° ì²˜ë¦¬ (ë‹¨ì–´ ë§¤ì¹­ ì‹œ moves +10)
// =====================================
async function resolveMatchesCascade() {
  let totalCleared = 0;
  let lastWord = "";

  while (true) {
    const marks = findMatches();
    if (marks.size === 0) break;

    const cleared = await clearMarked(marks);
    totalCleared += cleared.count;
    if (cleared.exampleWord) lastWord = cleared.exampleWord;

    applyGravity();
    refill();
    renderAll();
  }

  if (totalCleared > 0) {
    score += totalCleared * 5;
    updateScore();

    // ğŸ“Œ ë§¤ì¹­ ì„±ê³µ â†’ moves +10
    moves += 10;
    updateMoves();

    setMsg(lastWord
      ? `Cleared (${totalCleared}). ex: ${lastWord} â€” +10 moves`
      : `Cleared ${totalCleared} â€” +10 moves`
    );
  } else {
    setMsg("No match");
  }
}

function findMatches() {
  const marks = new Set();
  let example = "";

  // ê°€ë¡œ ê²€ì‚¬
  for (let r = 0; r < ROWS; r++) {
    let c = 0;
    while (c < COLS) {
      let c2 = c;
      while (c2 + 1 < COLS && grid[r][c2 + 1]) c2++;
      if (c2 - c + 1 >= MIN_WORD) {
        const letters = grid[r].slice(c, c2 + 1).join("");
        markSubstrings(r, c, 0, 1, letters, marks, w => (example ||= w));
      }
      c = c2 + 1;
    }
  }

  // ì„¸ë¡œ ê²€ì‚¬
  for (let c = 0; c < COLS; c++) {
    let r = 0;
    while (r < ROWS) {
      let r2 = r;
      while (r2 + 1 < ROWS && grid[r2 + 1][c]) r2++;
      if (r2 - r + 1 >= MIN_WORD) {
        let letters = "";
        for (let i = r; i <= r2; i++) letters += grid[i][c];
        markSubstrings(r, c, 1, 0, letters, marks, w => (example ||= w));
      }
      r = r2 + 1;
    }
  }

  marks.exampleWord = example;
  return marks;
}

function markSubstrings(r0, c0, dr, dc, letters, marks, onExample) {
  const n = letters.length;
  for (let len = MIN_WORD; len <= Math.min(n, MAX_WORD); len++) {
    for (let s = 0; s + len <= n; s++) {
      const word = letters.slice(s, s + len).toUpperCase();
      if (DICTIONARY.has(word)) {
        for (let k = 0; k < len; k++) {
          const rr = r0 + (s + k) * dr;
          const cc = c0 + (s + k) * dc;
          marks.add(`${rr},${cc}`);
        }
        if (onExample) onExample(word);
      }
    }
  }
}

async function clearMarked(marks) {
  const exampleWord = marks.exampleWord || "";

  for (const pos of marks) {
    const [r, c] = pos.split(",").map(Number);
    const el = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
    if (el) el.classList.add("match");
  }

  await new Promise(res => setTimeout(res, 500));

  let count = 0;
  for (const pos of marks) {
    const [r, c] = pos.split(",").map(Number);
    if (grid[r][c]) {
      grid[r][c] = "";
      count++;
    }
  }

  renderAll();
  return { count, exampleWord };
}

function applyGravity() {
  for (let c = 0; c < COLS; c++) {
    let w = ROWS - 1;
    for (let r = ROWS - 1; r >= 0; r--) {
      if (grid[r][c]) {
        grid[w][c] = grid[r][c];
        if (w !== r) grid[r][c] = "";
        w--;
      }
    }
  }
}

function refill() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (!grid[r][c]) {
        grid[r][c] = randLetter();
        colorGrid[r][c] = COLORS[Math.floor(Math.random() * COLORS.length)];
      }
    }
  }
}

// =====================================
// â— Shuffle
// =====================================
function shuffleBoard() {
  const arr = [];
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      arr.push(grid[r][c]);

  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }

  let k = 0;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      grid[r][c] = arr[k++];

  renderAll();
  setMsg("Shuffled");
}

</script>

<!-- â–¼ Service Worker -->
<script>
  const canSW =
    "serviceWorker" in navigator &&
    (location.protocol === "https:" ||
      location.hostname === "localhost" ||
      location.hostname === "127.0.0.1");

  if (canSW) {
    navigator.serviceWorker.register("sw.js").then(reg => {
      let refreshing = false;
      navigator.serviceWorker.addEventListener("controllerchange", () => {
        if (refreshing) return;
        refreshing = true;
        location.reload();
      });
    });
  }
</script>

</body>
</html>

