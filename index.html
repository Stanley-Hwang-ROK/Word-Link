<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Word-Link Puzzle ‚Äî Click-to-Swap</title>
  <link rel="manifest" href="manifest.json?v=6">
  <meta name="theme-color" content="#0f172a">

  <style>
    :root { --bg:#0f172a; --panel:#111827; --tile:#1f2937; --tileSel:#2563eb; --text:#e5e7eb; }
    body { margin:0; font-family: system-ui; background:var(--bg); color:var(--text); display:flex; min-height:100vh; }
    .wrap { margin:auto; width:min(95vw, 900px); }
    header { display:flex; align-items:center; justify-content:space-between; padding:12px 0; }

    .board {
      display: grid;
      gap: 6px;
      padding: 10px;
      grid-template-columns: repeat(8, 48px);  /* COLS = 8 */
      justify-content: center;
    }

    .tile {
      width:48px; height:48px;
      display:grid; place-items:center;
      border-radius:8px;
      background:var(--tile);
      color:#fff; font-weight:800; font-size:20px;
      user-select:none;
      border:1px solid #374151;
      transition:transform .08s ease;
    }
    .tile.sel { background:var(--tileSel); transform:scale(1.05); }
    .tile.match {
      background:#f59e0b;
      transform:scale(1.2);
      transition:all .3s ease;
    }

    .hud { display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 12px; }
    .badge { background:var(--panel); padding:6px 10px; border-radius:999px; font-weight:700; }
    .msg { min-height:20px; opacity:.9; }

    .category-btn {
      padding: 10px 16px;
      font-size: 16px;
      margin: 6px;
      border-radius: 6px;
      background:#2563eb;
      color:white;
      border:none;
      cursor:pointer;
    }

    /* moves Í∞ïÏ°∞ Ïï†ÎãàÎ©îÏù¥ÏÖò(ÏÑ†ÌÉù) */
    #moves {
      font-weight:900;
      color:#facc15;
      transition:transform .15s ease;
    }
    #moves.bump {
      transform:scale(1.25);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1 style="margin:0;font-size:20px">Word-Link (Click-to-Swap)</h1>
      <div>
        <button id="btnHint">Hint</button>
        <button id="btnShuffle">Shuffle</button>
        <button id="btnNew">New Game</button>
      </div>
    </header>

    <!-- üîπ Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù ÏòÅÏó≠ (header Î∞ñÏóê!) -->
    <div id="category-menu" style="text-align:center; margin:20px 0;">
      <h2 style="margin-bottom:8px;">Select a Category</h2>
      <button class="category-btn" data-cat="animal">Animals</button>
      <button class="category-btn" data-cat="plant">Plants</button>
      <button class="category-btn" data-cat="jobs">Jobs & Places</button>
    </div>

    <div class="hud">
      <div class="badge">Score: <span id="score">0</span></div>
      <div class="badge">Selected: <span id="currentWord"></span></div>
      <div class="badge">Moves: <span id="moves">10</span></div>
      <div class="badge">Dict: <span id="dictCount">0</span></div>
    </div>

    <div id="board" class="board"></div>
    <div id="msg" class="msg">Ïπ¥ÌÖåÍ≥†Î¶¨Î•º Î®ºÏ†Ä ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</div>
  </div>

<script>
/* =========================
   Word-Link (Category + Move Limit)
   ========================= */

const ROWS = 10, COLS = 8, MIN_WORD = 3, MAX_WORD = 6;
const COLORS = ["#f87171","#fbbf24","#34d399","#60a5fa","#a78bfa","#f472b6","#facc15","#38bdf8"];

// üîπ Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Îã®Ïñ¥ (ÎåÄÎ¨∏Ïûê)
const CATEGORY_WORDS = {
  animal: ["CAT","DOG","LION","TIGER","BEAR","FROG","BIRD","FISH","COW","PIG","FOX","DEER","BEE","DUCK"],
  plant:  ["TREE","LEAF","ROSE","GRASS","SEED","FLOWER","ROOT","MOSS","BAMBOO","OAK","PINE","LILY"],
  jobs:   ["DOCTOR","NURSE","TEACHER","PILOT","CHEF","FARMER","POLICE","DRIVER","ARTIST","BAKER","CLERK","GUIDE"]
};

let LETTER_BAG = "";                    // ÌòÑÏû¨ Ïπ¥ÌÖåÍ≥†Î¶¨ Í∏ÄÏûê Í∞ÄÎ∞©
function buildLetterBag(list){ return list.join(""); }

let DICTIONARY = new Set();
let grid = Array.from({length: ROWS}, () => Array(COLS).fill(""));
let colorGrid = Array.from({length: ROWS}, () => Array(COLS).fill(null));

let score = 0;
let moves = 10;                         // Ïä§Ïôë Í∞ÄÎä• ÌöüÏàò
let firstSel = null;                    // {r,c}

// DOM
const elBoard = document.getElementById("board");
const elMsg   = document.getElementById("msg");
const elScore = document.getElementById("score");
const elMoves = document.getElementById("moves");
const elWord  = document.getElementById("currentWord");
const elDict  = document.getElementById("dictCount");

// Í≥µÏö© UI Ìï®Ïàò
function setMsg(t){ elMsg.textContent = t; }
function updateScore(){ elScore.textContent = String(score); }
function updateMoves(){
  elMoves.textContent = String(moves);
  elMoves.classList.add("bump");
  setTimeout(() => elMoves.classList.remove("bump"), 150);
}
function setSelWord(t){ elWord.textContent = t; }

// ===== Î≥¥Îìú Í¥ÄÎ†® =====
function randLetter(){
  if (LETTER_BAG && LETTER_BAG.length > 0){
    const i = Math.floor(Math.random() * LETTER_BAG.length);
    return LETTER_BAG[i];
  }
  const bag = "EEEEEEAAA AAI IIOOOUU"
             + "NNNRRRTTTLLSS"
             + "DGG" + "BCMP" + "FHVWY" + "K" + "JX" + "QZ";
  const letters = bag.replace(/\s/g, "");
  return letters[Math.floor(Math.random()*letters.length)];
}

function setupBoard(){
  for (let r=0; r<ROWS; r++){
    for (let c=0; c<COLS; c++){
      grid[r][c] = randLetter();
      colorGrid[r][c] = COLORS[Math.floor(Math.random()*COLORS.length)];
    }
  }
}

function renderAll(){
  elBoard.innerHTML = "";
  for (let r=0; r<ROWS; r++){
    for (let c=0; c<COLS; c++){
      const d = document.createElement("div");
      d.className = "tile";
      d.dataset.r = r;
      d.dataset.c = c;
      d.textContent = grid[r][c];
      d.style.background = colorGrid[r][c];
      elBoard.appendChild(d);
    }
  }
}

// ===== Ïù¥Î≤§Ìä∏ Î∞îÏù∏Îî© =====
bindUI();
setMsg("Ïπ¥ÌÖåÍ≥†Î¶¨Î•º Î®ºÏ†Ä ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.");

function bindUI(){
  // ÌÉÄÏùº ÌÅ¥Î¶≠
  elBoard.addEventListener("click", onClickTile);

  // New Game
  document.getElementById("btnNew").onclick = () => {
    score = 0; updateScore();
    moves = 10; updateMoves();
    setupBoard();
    renderAll();
    setMsg("New board.");
  };

  // Shuffle
  document.getElementById("btnShuffle").onclick = () => {
    shuffleBoard();
  };

  // Hint
  document.getElementById("btnHint").onclick = () => {
    const h = findAnyMatch();
    setMsg(h ? `Ïòà: ${h.word}` : "Í∞ÄÎä•Ìïú Îã®Ïñ¥Î•º Î™ª Ï∞æÏïòÏñ¥Ïöî");
  };

  // üîπ Ïπ¥ÌÖåÍ≥†Î¶¨ Î≤ÑÌäº
  document.querySelectorAll(".category-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const cat = btn.dataset.cat;
      const words = CATEGORY_WORDS[cat];

      DICTIONARY = new Set(words);
      LETTER_BAG = buildLetterBag(words);

      if (elDict) elDict.textContent = String(DICTIONARY.size);

      // Î©îÎâ¥ Ïà®Í∏∞Í≥† Î≥¥Îìú ÏÉùÏÑ±
      document.getElementById("category-menu").style.display = "none";

      score = 0; updateScore();
      moves = 10; updateMoves();
      setupBoard();
      renderAll();

      setMsg(`${cat} category loaded (${DICTIONARY.size} words).`);
    });
  });
}

// ===== Ïä§Ïôë & ÌÅ¥Î¶≠ Î°úÏßÅ (moves Ï†ÅÏö©) =====
async function onClickTile(e){
  if (moves <= 0){
    setMsg("Game Over ‚Äî No moves left!");
    return;
  }

  const t = e.target.closest(".tile");
  if (!t) return;

  const r = +t.dataset.r, c = +t.dataset.c;

  if (!firstSel){
    firstSel = {r, c};
    highlight(r,c,true);
    setSelWord("");
    return;
  }

  if (firstSel.r === r && firstSel.c === c){
    highlight(r,c,false);
    firstSel = null;
    return;
  }

  if (!isNeighbor(firstSel.r, firstSel.c, r, c)){
    highlight(firstSel.r, firstSel.c, false);
    firstSel = {r, c};
    highlight(r,c,true);
    return;
  }

  // Ïã§Ï†ú Ïä§Ïôë
  swap([firstSel.r, firstSel.c],[r,c]);
  highlight(firstSel.r, firstSel.c,false);
  highlight(r,c,false);
  firstSel = null;

  // Ïä§ÏôëÌïòÎ©¥ moves -1
  moves -= 1;
  updateMoves();

  if (moves <= 0){
    renderAll();
    setMsg("Game Over ‚Äî No moves left!");
    return;
  }

  renderAll();
  await resolveMatchesCascade();
}

function highlight(r,c,on){
  const el = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
  if (el) el.classList.toggle("sel", !!on);
}
function isNeighbor(r1,c1,r2,c2){
  return Math.abs(r1-r2)+Math.abs(c1-c2)===1;
}
function swap([r1,c1],[r2,c2]){
  let t = grid[r1][c1];
  grid[r1][c1] = grid[r2][c2];
  grid[r2][c2] = t;

  let tc = colorGrid[r1][c1];
  colorGrid[r1][c1] = colorGrid[r2][c2];
  colorGrid[r2][c2] = tc;
}

// ===== Îß§Ïπò ÌÉêÏÉâ & Ï≤òÎ¶¨ =====
async function resolveMatchesCascade(){
  let totalCleared = 0;
  let lastWord = "";

  while (true){
    const marks = findMatches();
    if (marks.size === 0) break;

    const cleared = await clearMarked(marks);
    totalCleared += cleared.count;
    if (cleared.exampleWord) lastWord = cleared.exampleWord;

    applyGravity();
    refill();
    renderAll();
  }

  if (totalCleared > 0){
    score += totalCleared * 5;
    updateScore();

    // Îß§Ïπ≠ÌïòÎ©¥ moves +10
    moves += 10;
    updateMoves();

    setMsg(
      lastWord
        ? `Cleared (${totalCleared}). ex: ${lastWord} ‚Äî +10 moves`
        : `Cleared ${totalCleared} ‚Äî +10 moves`
    );
  } else {
    setMsg("No match");
  }
}

function findMatches(){
  const marks = new Set();
  let example = "";

  // Í∞ÄÎ°ú
  for (let r=0; r<ROWS; r++){
    let c = 0;
    while (c < COLS){
      let c2 = c;
      while (c2+1 < COLS && grid[r][c2+1]) c2++;
      if (c2 - c + 1 >= MIN_WORD){
        const letters = grid[r].slice(c, c2+1).join("");
        markSubstrings(r,c,0,1,letters,marks, w => { if (!example) example = w; });
      }
      c = c2 + 1;
    }
  }

  // ÏÑ∏Î°ú
  for (let c=0; c<COLS; c++){
    let r = 0;
    while (r < ROWS){
      let r2 = r;
      while (r2+1 < ROWS && grid[r2+1][c]) r2++;
      if (r2 - r + 1 >= MIN_WORD){
        let letters = "";
        for (let i=r; i<=r2; i++) letters += grid[i][c];
        markSubstrings(r,c,1,0,letters,marks, w => { if (!example) example = w; });
      }
      r = r2 + 1;
    }
  }

  marks.exampleWord = example;
  return marks;
}

function markSubstrings(r0,c0,dr,dc,letters,marks,onExample){
  const n = letters.length;
  for (let len=MIN_WORD; len<=Math.min(n,MAX_WORD); len++){
    for (let s=0; s+len<=n; s++){
      const word = letters.slice(s,s+len).toUpperCase();
      if (DICTIONARY.has(word)){
        for (let k=0; k<len; k++){
          const rr = r0 + (s+k)*dr;
          const cc = c0 + (s+k)*dc;
          marks.add(`${rr},${cc}`);
        }
        if (onExample) onExample(word);
      }
    }
  }
}

async function clearMarked(marks){
  const exampleWord = marks.exampleWord || "";
  for (const pos of marks){
    const [r,c] = pos.split(",").map(Number);
    const el = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
    if (el) el.classList.add("match");
  }

  await new Promise(res => setTimeout(res, 500));

  let count = 0;
  for (const pos of marks){
    const [r,c] = pos.split(",").map(Number);
    if (grid[r][c]){
      grid[r][c] = "";
      count++;
    }
  }

  renderAll();
  return { count, exampleWord };
}

function applyGravity(){
  for (let c=0; c<COLS; c++){
    let write = ROWS-1;
    for (let r=ROWS-1; r>=0; r--){
      if (grid[r][c]){
        grid[write][c] = grid[r][c];
        if (write !== r) grid[r][c] = "";
        write--;
      }
    }
  }
}

function refill(){
  for (let r=0; r<ROWS; r++){
    for (let c=0; c<COLS; c++){
      if (!grid[r][c]){
        grid[r][c] = randLetter();
        colorGrid[r][c] = COLORS[Math.floor(Math.random()*COLORS.length)];
      }
    }
  }
}

function shuffleBoard(){
  const arr = [];
  for (let r=0; r<ROWS; r++)
    for (let c=0; c<COLS; c++)
      arr.push(grid[r][c]);

  for (let i=arr.length-1; i>0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }

  let k = 0;
  for (let r=0; r<ROWS; r++)
    for (let c=0; c<COLS; c++)
      grid[r][c] = arr[k++];

  renderAll();
  setMsg("Shuffled");
}
</script>

<script>
  // service worker
  const canSW = 'serviceWorker' in navigator &&
    (location.protocol === 'https:' ||
     location.hostname === 'localhost' ||
     location.hostname === '127.0.0.1');

  if (canSW) {
    navigator.serviceWorker.register('sw.js').then(reg => {
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (refreshing) return;
        refreshing = true;
        location.reload();
      });
    }).catch(console.error);
  }
</script>

</body>
</html>

